<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>...</title>
    <script type="text/javascript" src="./src/Typr.js"></script>
    <script type="text/javascript" src="./src/Typr.U.js"></script>
    <script type="text/javascript">
      var font;
      var uncd = null;
      var result = {
        info: {},
        copyright: {},
        variable: {},
        features: {},
        support: {},
      };

      async function load(path) {
        try {
          const response = await fetch(path);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return await response.arrayBuffer();
        } catch (error) {
          console.error("加载文件时出错:", error);
        }
      }

      function go() {
        load("NotoSansSC-VF.ttf").then(fontLoaded);

        var node = document.body;
        node.addEventListener("drop", onDrop, false);
        node.addEventListener("dragenter", cancel, false);
        node.addEventListener("dragleave", cancel, false);
        node.addEventListener("dragover", cancel, false);
      }
      function cancel(e) {
        e.stopPropagation();
        e.preventDefault();
      }

      function onDrop(e) {
        cancel(e);
        var r = new FileReader();
        r.onload = function (e) {
          fontLoaded(e.target.result);
        };
        r.readAsArrayBuffer(e.dataTransfer.files[0]);
      }

      function calculateCoverage(intervals, arr) {
        let coveredCount = 0;
        let intervalIndex = 0;
        let intervalsLength = 0;

        for (const iterator of intervals) {
          // 计算每个区间的长度
          intervalsLength += iterator[iterator.length - 1] - iterator[0] + 1;
        }

        for (const num of arr) {
          // 当区间未遍历完并且当前数字在当前区间内
          while (
            intervalIndex < intervals.length &&
            num > intervals[intervalIndex].slice(-1)
          ) {
            intervalIndex++;
          }
          // 检查当前数字是否在当前区间内
          if (
            intervalIndex < intervals.length &&
            num >= intervals[intervalIndex][0] &&
            num <= intervals[intervalIndex].slice(-1)
          ) {
            coveredCount++;
          }
        }

        return [coveredCount, intervalsLength];
      }

      function fontLoaded(resp) {
        const start = new Date().getTime();
        font = Typr.parse(resp)[0];
        console.log(font);
        document.title = font.name.fullName;
        document.getElementById(
          "report"
        ).innerHTML = `${font.name.fullName}</br>`;

        result["info"]["fullName"] = font.name.fullName;
        result["info"]["fontFamily"] = font.name.fontFamily;
        result["info"]["version"] = font.name.version;
        result["info"]["manufacturer"] = font.name.manufacturer;
        result["info"]["designer"] = font.name.designer;
        result["copyright"]["copyright"] = font.name.copyright;
        result["copyright"]["licence"] = font.name.licence;
        result["copyright"]["URL"] = font.name.licenceURL;

        var glyphCounts = font.maxp.numGlyphs;
        result["info"]["glyphs"] = glyphCounts;

        uncd = new Set();
        // 遍历所有 Unicode 码点，直到找到所有字形
        // TODO 遍历次数太多，效率太低
        for (let i = 0, j = 0; i <= 0x10ffff && j < glyphCounts; i++) {
          let gid = Typr.U.codeToGlyph(font, i);
          if (gid === 0) continue;
          uncd.add(i);
          j++;
        }

        result["info"]["characters"] = uncd.size;

        processJsonFiles();

        drawWord();
        console.log(result);

        const end = new Date().getTime();
        console.log(`Processing time:`, `${end - start}ms`);
      }

      function processJsonFiles() {
        const jsonFolder = "./data/";

        fetch(jsonFolder)
          .then((response) => response.text())
          .then((text) => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(text, "text/html");
            const fileLinks = Array.from(htmlDoc.querySelectorAll("a"))
              .filter((a) => a.href.endsWith(".json"))
              .map((a) => a.href);

            return Promise.all(fileLinks.map((file) => processJsonFile(file)));
          })
          .catch((error) => console.error("Error listing JSON files:", error));
      }

      function processJsonFile(file) {
        return fetch(file)
          .then((response) => response.json())
          .then((data) => {
            result["support"][data.id] = {};

            const categories = [
              "base",
              "auxiliary",
              "strict",
              "numerals",
              "punctuation",
            ];

            let allCoverage = [0, 0];
            categories.forEach((category) => {
              if (data.exemplar_chars[category]) {
                const coverage = calculateCoverage(
                  data.exemplar_chars[category],
                  uncd
                );

                result["support"][data.id][category] = [
                  coverage[0],
                  coverage[1],
                ];

                allCoverage[0] += coverage[0];
                allCoverage[1] += coverage[1];
              }
            });

            result["support"][data.id]["all"] = allCoverage;
            document.getElementById("report").innerHTML += `<br/>${
              data.autonym
            } - ${((100 * allCoverage[0]) / allCoverage[1]).toFixed(2)} - ${
              allCoverage[0]
            } / ${allCoverage[1]} `;
          })
          .catch((error) => console.error(`Error processing ${file}:`, error));
      }

      function drawWord(e) {
        var cnv = document.getElementById("wordcanvas");
        cnv.width = Math.floor(800 * getDPR());
        cnv.height = Math.floor(130 * getDPR());
        scaleCnv(cnv);
        var ctx = cnv.getContext("2d");

        var scale = (80 * getDPR()) / font.head.unitsPerEm;

        var shape = Typr.U.shape(font, document.getElementById("word").value);
        var path = Typr.U.shapeToPath(font, shape);

        //var spath = document.getElementById("svgp");  spath.setAttribute("d", Typr.U.pathToSVG(path));

        cnv.width = cnv.width;
        ctx.translate(4 * getDPR(), 100 * getDPR());

        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, cnv.width, 1);
        ctx.fillRect(0, -Math.round(font.hhea.ascender * scale), cnv.width, 1);
        ctx.fillRect(0, -Math.round(font.hhea.descender * scale), cnv.width, 1);

        ctx.scale(scale, -scale);

        Typr.U.pathToContext(path, ctx); // setting color and calling fill() already in path
        ctx.fill();
      }

      function getDPR() {
        return window["devicePixelRatio"] || 1;
      }
      function scaleCnv(cnv) {
        cnv.setAttribute(
          "style",
          "width:" +
            cnv.width / getDPR() +
            "px; height:" +
            cnv.height / getDPR() +
            "px"
        );
      }
    </script>
    <style type="text/css">
      body {
        background-color: #ceedf4;
        margin: 0;
        padding: 0;
        line-height: 1.6em;
        color: rgb(51, 51, 51);
      }
      .main {
        margin: 0 auto;
        max-width: 50em;

        padding: 0.5em 2em;
        background-color: #ffffff;
      }
    </style>
  </head>

  <body onload="go();">
    <div class="main">
      <input
        id="word"
        type="text"
        value="测试 Test"
        style="font-size: 1.5em; width: 100%; margin-top: 1em"
        oninput="drawWord()"
      />
      <canvas id="wordcanvas"></canvas>
      <div id="report"></div>
    </div>
  </body>
</html>
