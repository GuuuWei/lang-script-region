<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>...</title>
    <script type="text/javascript" src="./Typr.js"></script>
    <script type="text/javascript" src="./Typr.U.js"></script>
    <script type="text/javascript">
      var font;
      var uncd = null;

      async function load(path) {
        try {
          const response = await fetch(path);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return await response.arrayBuffer();
        } catch (error) {
          console.error("加载文件时出错:", error);
        }
      }

      function go() {
        load("NotoSansSC-VF.ttf").then(fontLoaded);

        var node = document.body;
        node.addEventListener("drop", onDrop, false);
        node.addEventListener("dragenter", cancel, false);
        node.addEventListener("dragleave", cancel, false);
        node.addEventListener("dragover", cancel, false);
      }
      function cancel(e) {
        e.stopPropagation();
        e.preventDefault();
      }

      function onDrop(e) {
        cancel(e);
        var r = new FileReader();
        r.onload = function (e) {
          fontLoaded(e.target.result);
        };
        r.readAsArrayBuffer(e.dataTransfer.files[0]);
      }

      function calculateCoverage(intervals, arr) {
        let coveredCount = 0; // 记录覆盖的元素数
        let intervalIndex = 0; // 当前区间A的索引
        let intervalsLength = 0;

        for (const iterator of intervals) {
          // 计算每个区间的长度
          intervalsLength += iterator[iterator.length - 1] - iterator[0] + 1;
        }

        for (const num of arr) {
          // 当区间未遍历完并且当前数字在当前区间内
          while (
            intervalIndex < intervals.length &&
            num > intervals[intervalIndex].slice(-1)
          ) {
            intervalIndex++; // 移动到下一个区间
          }
          // 检查当前数字是否在当前区间内
          if (
            intervalIndex < intervals.length &&
            num >= intervals[intervalIndex][0] &&
            num <= intervals[intervalIndex].slice(-1)
          ) {
            coveredCount++; // 增加覆盖计数
          }
        }

        return [coveredCount, intervalsLength];
      }

      function fontLoaded(resp) {
        font = Typr.parse(resp)[0];
        console.log(font);
        document.title = font.name.fullName;
        document.getElementById("result").innerHTML = `${font.name.fullName}`;

        var glyphCounts = font.maxp.numGlyphs;
        uncd = new Set();
        // Unicode 的最大码点是 0x10FFFF
        for (let i = 0, j = 0; i <= 0x10ffff && j < glyphCounts; i++) {
          let gid = Typr.U.codeToGlyph(font, i);
          if (gid === 0) continue;
          uncd.add(i);
          j++;
        }

        processJsonFiles();

        drawWord();
      }

      function processJsonFiles() {
        const start = new Date().getTime();
        const jsonFolder = "./data/";

        fetch(jsonFolder)
          .then((response) => response.text())
          .then((text) => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(text, "text/html");
            const fileLinks = Array.from(htmlDoc.querySelectorAll("a"))
              .filter((a) => a.href.endsWith(".json"))
              .map((a) => a.href);

            return Promise.all(
              fileLinks.map((file) => processJsonFile(file, start))
            );
          })
          .catch((error) => console.error("Error listing JSON files:", error));
      }

      function processJsonFile(file, start) {
        return fetch(file)
          .then((response) => response.json())
          .then((data) => {
            console.log(data.id);
            document.getElementById(
              "result"
            ).innerHTML += `<br/><br/>${data.id}`;
            document.getElementById(
              "result"
            ).innerHTML += `<br/>${data.autonym}`;

            const categories = [
              "base",
              "auxiliary",
              "strict",
              "numerals",
              "punctuation",
            ];

            categories.forEach((category) => {
              if (data.exemplar_chars[category]) {
                const coverage = calculateCoverage(
                  data.exemplar_chars[category],
                  uncd
                );
                console.log(`${category} coverage:`, coverage);
                document.getElementById(
                  "result"
                ).innerHTML += `<br/>${category} : ${coverage[0]} / ${coverage[1]}`;
              }
            });

            const end = new Date().getTime();
            console.log(`Processing time:`, `${end - start}ms`);
          })
          .catch((error) => console.error(`Error processing ${file}:`, error));
      }

      function drawWord(e) {
        var cnv = document.getElementById("wordcanvas");
        cnv.width = Math.floor(800 * getDPR());
        cnv.height = Math.floor(130 * getDPR());
        scaleCnv(cnv);
        var ctx = cnv.getContext("2d");

        var scale = (80 * getDPR()) / font.head.unitsPerEm;

        var shape = Typr.U.shape(font, document.getElementById("word").value);
        var path = Typr.U.shapeToPath(font, shape);

        //var spath = document.getElementById("svgp");  spath.setAttribute("d", Typr.U.pathToSVG(path));

        cnv.width = cnv.width;
        ctx.translate(4 * getDPR(), 100 * getDPR());

        ctx.fillStyle = "#000000";
        ctx.fillRect(0, 0, cnv.width, 1);
        ctx.fillRect(0, -Math.round(font.hhea.ascender * scale), cnv.width, 1);
        ctx.fillRect(0, -Math.round(font.hhea.descender * scale), cnv.width, 1);

        ctx.scale(scale, -scale);

        Typr.U.pathToContext(path, ctx); // setting color and calling fill() already in path
        ctx.fill();
      }

      function getDPR() {
        return window["devicePixelRatio"] || 1;
      }
      function scaleCnv(cnv) {
        cnv.setAttribute(
          "style",
          "width:" +
            cnv.width / getDPR() +
            "px; height:" +
            cnv.height / getDPR() +
            "px"
        );
      }
    </script>
    <style type="text/css">
      body {
        background-color: #ceedf4;
        margin: 0;
        padding: 0;
        line-height: 1.6em;
        color: rgb(51, 51, 51);
      }
      .main {
        margin: 0 auto;
        max-width: 50em;

        padding: 0.5em 2em;
        background-color: #ffffff;
      }
    </style>
  </head>

  <body onload="go();">
    <div class="main">
      <input
        id="word"
        type="text"
        value="测试 Test"
        style="font-size: 1.5em; width: 100%; margin-top: 1em"
        oninput="drawWord()"
      />
      <canvas id="wordcanvas"></canvas>
      <div id="result"></div>
    </div>
  </body>
</html>
